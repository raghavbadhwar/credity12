// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import { AccessControl } from "@openzeppelin/contracts/access/AccessControl.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import { Pausable } from "@openzeppelin/contracts/utils/Pausable.sol";
import { IGroth16Verifier3, IGroth16Verifier5 } from "./IGroth16Verifier.sol";

/**
 * @title ReputationVerifier
 * @dev PRD v2.0 aligned contract for zk proof verification on Polygon zkEVM.
 *      Accepts Groth16 proof points generated by snarkjs/circom pipelines.
 *      Hardened: typed interfaces, chain binding, pause, replay protection.
 */
contract ReputationVerifier is AccessControl, ReentrancyGuard, Pausable {
    bytes32 public constant PROOF_ADMIN_ROLE = keccak256("PROOF_ADMIN_ROLE");

    /// @dev Circuit IDs 1 and 2 use verifiers with 3 public signals
    mapping(uint256 => IGroth16Verifier3) public zkVerifier3ByCircuit;
    /// @dev Circuit ID 3 uses a verifier with 5 public signals
    IGroth16Verifier5 public zkVerifier5;

    /// @dev circuitId => expected public signal length
    mapping(uint256 => uint256) public expectedPublicSignalsLength;

    /// @dev Tracks submitted proofs (domain-separated per chain + contract)
    mapping(bytes32 => bool) public proofExists;

    /// @dev Tracks submitters of each proof for attribution
    mapping(bytes32 => address) public proofSubmitter;

    /// @dev Nonce per submitter to prevent exact-replay across time
    mapping(address => uint256) public submitterNonce;

    event ZkVerifier3Updated(uint256 indexed circuitId, address indexed oldVerifier, address indexed newVerifier, address updatedBy);
    event ZkVerifier5Updated(address indexed oldVerifier, address indexed newVerifier, address updatedBy);
    event ExpectedPublicSignalsLengthUpdated(uint256 indexed circuitId, uint256 oldLength, uint256 newLength, address updatedBy);
    event ProofVerified(bytes32 indexed proofHash, address indexed submitter, uint256 indexed circuitId, uint256 nonce);

    error InvalidVerifier();
    error InvalidProof();
    error InvalidCircuitId(uint256 circuitId);
    error PublicSignalsLengthMismatch(uint256 circuitId, uint256 expected, uint256 actual);
    error ProofAlreadyStored(bytes32 proofHash);
    error VerifierHasNoCode(address verifierAddress);

    constructor(address scoreThresholdVerifier, address ageVerificationVerifier, address crossVerticalAggregateVerifier) {
        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _grantRole(PROOF_ADMIN_ROLE, msg.sender);

        _setCircuitVerifier3(1, scoreThresholdVerifier);
        _setCircuitVerifier3(2, ageVerificationVerifier);
        _setCircuitVerifier5(crossVerticalAggregateVerifier);

        // public inputs include circuitId + circuit-specific inputs
        _setExpectedPublicSignalsLength(1, 3); // [circuitId, threshold, commitment]
        _setExpectedPublicSignalsLength(2, 3); // [circuitId, cutoffDate, commitment]
        _setExpectedPublicSignalsLength(3, 5); // [circuitId, minVerticals, minScorePerVertical, minAverageScore, commitment]
    }

    // ──────────────────── Admin: Pause ────────────────────

    function pause() external onlyRole(DEFAULT_ADMIN_ROLE) {
        _pause();
    }

    function unpause() external onlyRole(DEFAULT_ADMIN_ROLE) {
        _unpause();
    }

    // ──────────────────── Admin: Verifier rotation ────────────────────

    function setCircuitVerifier3(uint256 circuitId, address verifierAddress) external onlyRole(PROOF_ADMIN_ROLE) {
        _setCircuitVerifier3(circuitId, verifierAddress);
    }

    function setCircuitVerifier5(address verifierAddress) external onlyRole(PROOF_ADMIN_ROLE) {
        _setCircuitVerifier5(verifierAddress);
    }

    function setExpectedPublicSignalsLength(uint256 circuitId, uint256 newLength) external onlyRole(PROOF_ADMIN_ROLE) {
        _setExpectedPublicSignalsLength(circuitId, newLength);
    }

    // ──────────────────── Core: Verify & Store ────────────────────

    /**
     * @dev Verify a Groth16 proof and store it on-chain.
     *      circuitId is read from pubSignals[0]:
     *        1=score_threshold (3 signals), 2=age_verification (3 signals), 3=cross_vertical_aggregate (5 signals)
     *
     *      Hardened protections:
     *       - Chain + contract address bound into proof hash (prevents cross-chain replay)
     *       - msg.sender bound into proof hash (prevents proof theft)
     *       - Per-submitter nonce prevents exact replay across time
     *       - Pausable for emergency stops
     */
    function verifyAndStoreProof(
        uint256[2] calldata pA,
        uint256[2][2] calldata pB,
        uint256[2] calldata pC,
        uint256[] calldata pubSignals
    ) external nonReentrant whenNotPaused returns (bool) {
        if (pubSignals.length == 0) revert InvalidCircuitId(0);

        uint256 circuitId = pubSignals[0];
        if (!_isSupportedCircuit(circuitId)) revert InvalidCircuitId(circuitId);

        uint256 expectedLength = expectedPublicSignalsLength[circuitId];
        if (pubSignals.length != expectedLength) {
            revert PublicSignalsLengthMismatch(circuitId, expectedLength, pubSignals.length);
        }

        // Route to correctly-typed verifier
        bool isValid;
        if (circuitId == 1 || circuitId == 2) {
            IGroth16Verifier3 verifier = zkVerifier3ByCircuit[circuitId];
            uint[3] memory signals3;
            signals3[0] = pubSignals[0];
            signals3[1] = pubSignals[1];
            signals3[2] = pubSignals[2];
            isValid = verifier.verifyProof(
                _toUint2(pA), _toUint2x2(pB), _toUint2(pC), signals3
            );
        } else {
            // circuitId == 3
            uint[5] memory signals5;
            signals5[0] = pubSignals[0];
            signals5[1] = pubSignals[1];
            signals5[2] = pubSignals[2];
            signals5[3] = pubSignals[3];
            signals5[4] = pubSignals[4];
            isValid = zkVerifier5.verifyProof(
                _toUint2(pA), _toUint2x2(pB), _toUint2(pC), signals5
            );
        }

        if (!isValid) revert InvalidProof();

        // Domain-separated proof hash:
        //  - block.chainid: prevents cross-chain replay
        //  - address(this): prevents cross-contract replay
        //  - msg.sender: prevents proof theft (another user submitting your proof)
        //  - submitterNonce: prevents exact-replay across time
        uint256 nonce = submitterNonce[msg.sender]++;
        bytes32 proofHash = keccak256(
            abi.encodePacked(
                block.chainid,
                address(this),
                msg.sender,
                nonce,
                pA,
                pB,
                pC,
                pubSignals
            )
        );

        if (proofExists[proofHash]) revert ProofAlreadyStored(proofHash);
        proofExists[proofHash] = true;
        proofSubmitter[proofHash] = msg.sender;

        emit ProofVerified(proofHash, msg.sender, circuitId, nonce);
        return true;
    }

    // ──────────────────── View functions ────────────────────

    function getVerifier3(uint256 circuitId) external view returns (address) {
        return address(zkVerifier3ByCircuit[circuitId]);
    }

    function getVerifier5() external view returns (address) {
        return address(zkVerifier5);
    }

    // ──────────────────── Internal ────────────────────

    function _setCircuitVerifier3(uint256 circuitId, address verifierAddress) internal {
        if (circuitId != 1 && circuitId != 2) revert InvalidCircuitId(circuitId);
        if (verifierAddress == address(0)) revert InvalidVerifier();
        if (verifierAddress.code.length == 0) revert VerifierHasNoCode(verifierAddress);

        address old = address(zkVerifier3ByCircuit[circuitId]);
        zkVerifier3ByCircuit[circuitId] = IGroth16Verifier3(verifierAddress);
        emit ZkVerifier3Updated(circuitId, old, verifierAddress, msg.sender);
    }

    function _setCircuitVerifier5(address verifierAddress) internal {
        if (verifierAddress == address(0)) revert InvalidVerifier();
        if (verifierAddress.code.length == 0) revert VerifierHasNoCode(verifierAddress);

        address old = address(zkVerifier5);
        zkVerifier5 = IGroth16Verifier5(verifierAddress);
        emit ZkVerifier5Updated(old, verifierAddress, msg.sender);
    }

    function _setExpectedPublicSignalsLength(uint256 circuitId, uint256 newLength) internal {
        if (!_isSupportedCircuit(circuitId)) revert InvalidCircuitId(circuitId);
        uint256 oldLength = expectedPublicSignalsLength[circuitId];
        expectedPublicSignalsLength[circuitId] = newLength;
        emit ExpectedPublicSignalsLengthUpdated(circuitId, oldLength, newLength, msg.sender);
    }

    function _isSupportedCircuit(uint256 circuitId) internal pure returns (bool) {
        return circuitId >= 1 && circuitId <= 3;
    }

    /// @dev Convert uint256[2] calldata to uint[2] memory for verifier call
    function _toUint2(uint256[2] calldata src) internal pure returns (uint[2] memory dst) {
        dst[0] = src[0];
        dst[1] = src[1];
    }

    /// @dev Convert uint256[2][2] calldata to uint[2][2] memory for verifier call
    function _toUint2x2(uint256[2][2] calldata src) internal pure returns (uint[2][2] memory dst) {
        dst[0][0] = src[0][0];
        dst[0][1] = src[0][1];
        dst[1][0] = src[1][0];
        dst[1][1] = src[1][1];
    }
}
